import { createSlice, current } from '@reduxjs/toolkit'

const initialState = [
  {
    content: 'reducer defines how redux store works',
    important: true,
    id: 1,
  },
  {
    content: 'state of store can contain any data',
    important: false,
    id: 2,
  },
]

const generateId = () =>
  Number((Math.random() * 1000000).toFixed(0))


// name, initialState, reducers are prefined fixed name in createSlice
const noteSlice = createSlice({
  name: 'notes',
  initialState,  // shorthand when if the names of key and value are the same => initialState: initialState
  reducers: {
    createNote(state, action) {  // shorthand for functions => create: function (state, action) {...}
      const content = action.payload
      state.push({
        content,
        important: false,
        id: generateId(),
      })  
    },
    toggleImportanceOf(state, action) {
      const id = action.payload
      const noteToChange = state.find(n => n.id === id)
      const changedNote = { 
        ...noteToChange, 
        important: !noteToChange.important 
      }
      console.log(current(state))
      return state.map(note =>
        note.id !== id ? note : changedNote 
      )     
    }
  },
})



export const { createNote, toggleImportanceOf } = noteSlice.actions
export default noteSlice.reducer
/* createSlice returns an object containing the reducer and action creators.
   the reducer can be accessed by the noteSlice.reducer property
   the action creators by the noteSlice.actions property

   action creators are generated by createSlice based on the name and the name of functions in reducers
   this action creator will assign <name>/<function_name> as type, assign input as payload
   noteSlice.actions.createNote("Hello") => { type: "notes/createNote", payload: "Hello"}
   dispatch(noteSlice.actions.createNote("Hello")) => call the createNote reducer defined in reducers and alter the state
*/

/* Redux toolkit and Immer Library
every time users call dispatch and call the reducer, RTK and Immer generate a draft state based on the lastest state in store
users can mutate the draft directly, after reducer is finished, RTK and Immer generate a snapshot based on the mutated draft
when user call getState, RTK and Immer always return the lastest snapshot in store
*/